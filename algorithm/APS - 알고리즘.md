# APS - 알고리즘 이론

> 2021.04.07.

- 어떻게 프로그램을 짜면 더 빠른지, 더 느린지 전혀 감이 없다
- log n 의 밑은 2이다.

*논리적으로 정확하게 확인하는 과정에 대한 연습이 필요하다*

즉 프로그램을 짜기 시작하기 전에, 정확한 결과가 나올 것인지, 얼마나 빠르게 돌아갈 것인지 미리 알 수 있는가를 예측해보자. 정확히 확인하는 훈련이 되어 있다면 코드를 응용하고, 다른 사람의 코드를 고치기에 수월하다.

#### 논리 Logic

##### Soft-logic vs Hard-logic

```python
""" 카드 문제
사실 : 모든 카드의 한쪽에는 알파벳이, 다른 쪽에는 숫자가 써 있음
주장 : 만약 한쪽이 D 이면 반대쪽은 3
주장이 사실인지 확인하기 위해 다음 카드들 중 반드시 뒤집어 보아야 하는 것은 몇 개이고 어느 것인가?
D F 3 7
"""
D 7
```

```python
"""맥주집 문제
규칙 : 20세 이하인 사람은 맥주를 마실 수 없음
나이 혹은 마시고 있는 것을 표시한 다음 4명 중 확인이 필요한 사람은 몇 명이고 누구인가?
17 31 콜라 맥주
"""
17 맥주
```



## 1. 명제와 증명

### 1.1. 명제

- 참이나 거짓을 알 수 있는 식이나 선언적 문장

#### 진릿값

- 참이나 거짓을 표현

#### 논리연산

- 논리곱 AND
  - p, q가 명제일 때, p ^ q 모두가 참일 때만 참이 되는 명제
- 논리합 OR
  - p V q
- 배타적 논리합 XOR
  - p Θ q (O가운데 +) 

```python
# 리스트 원소 중에 개수가 홀수 인 정수를 찾습니다.
from functools import reduce

numbers = [1, 1, 2, 2, 3]
9
def xor(x, y):
    return x ^ y

print(reduce(xor., numbers))
```

- 합성
  - 우선순위 : ㄱ(not) > V, ^ (AND OR) > →, ↔
  - 항진명제 : 진릿값이 항상 참
  - 모순명제 : 진릿값이 항상 거짓
  - 사건명제 : 항진명제도 모순명제도 아닌 명제

#### 조건명제

- p, q가 명제일 때, 명제 p가 조건(도는 원인), q가 결론로 제시되는 명제

- p → q (p 이면 q이다. )

  | p    | q    | p → q             |
  | ---- | ---- | ----------------- |
  | T    | T    | T                 |
  | T    | F    | F                 |
  | F    | T    | T (vacuous truth) |
  | F    | F    | T (vacuous truth) |

- `오로지 p : T, q : F 일때만 → F 가 나온다.`

-  vacuous truth 공허한 참값 

  - 방에있는 모든 휴대 전화가 꺼져 있습니다....

#### 쌍방조건명제

- p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
- p ↔ q (p면 q고, q면 p다.)

#### 조건명제(p → q)의 역, 이, 대우

- 역 : q → p
- 이 : ㄱ p → ㄱ q 
- 대우 : ㄱq → ㄱp

##### 연습문제

```python
# 논리 연습
1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.
	p : F , q : ??  → T (p가 F가 나온다면 무조건 T로 나온다.)
2. 만약 198293819283975이 Prime Number라면, 2는 짝수이다.
	p : ?? , q : T  → T (q가 T가 나온다면 무조건 T로 나온다.)
```

```python
# 논리 연습2
p와 q가 명제이고 p → q가 거짓이라고 하자. 
1. ~p → q
2. p V q
3. q → p

# 해설
p : T, q : F 이다.
1. F → F : T
2. T V F : T
3. F → T : T 
```

```python
# 논리 연습3 : 역, 이, 대우
1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.
2. 만약 198293819283975이 Prime Number라면, 2는 짝수이다.
```

```python
# 논리 연습4 : 진리표
1. p ^ (q → ~p)
2. (p ^ ~q) → r

# 해설1
p	q	~q	(q → ~p)	p ^ (q → ~p)
T	T	F		F			F
T	F	F		T			T
F	T	T		T			F
F	F	T		T			F

# 해설2
p	q	r	~q	p^~q	(p ^ ~q) → r
T	T	T	F
T	T	F	F
T	F	T	T
T	F	F	T
F	T	T	F
F	T	F	F
F	F	T	T
F	F	F	T
```

### 1.2. 증명

- 증명은 정확한 명제식으로 표현할 수 있는 것이라야 함
- 보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음
- 증명에 대한 수많은 오해가 P → Q 를 P ↔ Q와 혼동하는 것에서 일어남

```python
# i.g. 모든 당구공은 색이 같다는 증명에서 잘못된 것은?
- 수학적 귀납법 : P(1)이 참이고, P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.
- P(1) : 당구공 1개가 들어있는 집합은 모두 색이 같음
- P(n) -> P(n+1)을 증명하기 위해 P(n)이 참이라고 가정
- 당구공 n+1개가 들어 있는 임의의 집합을 생각함
- 1에서 2로 빼낼 때 같다는 조건이 없다..
```

```python
# i.g. Prime Number의 개수는 무한히 많다는 증명은 옳은가?
- Prime Number의 개수가 유한한 K개라고 가정
- 모든 Prime Number를 다 곱하고 1을 더한 수를 n이라고 하자
- 이 수 n은 어떤 Prime으로 나누어도 나머지가 1이다
- 그런데 n은 어떤 Prime보다도 크므로 합성수이다.
- 합성수이지만 어떤 Prime으로도 나누어지지 않으므로 모순 발생
- 즉, Prime Number가 K개 라는 명제가 항상 거짓일 수 밖에 없다!
```

#### 수학적 귀납법과 증명의 수준

- 수학적 귀납법의 기본형 : P(1)이 참이고, P(n) -> P(n+1) 이 참이면 P(n) 참이다.
- 수학적 귀납법의 강한 형태 : P(1)이 참이고, P(1)^P(2)^....^P(n+1)이 참이면 P(n)은 참이다.

```python
# 1부터 x까지 합을 계산함을 증명해 보자
- sum(1) = 1이다. (참)
- sum(x) = x + sum(x-1) (참)
```

```python
# 소팅의 사례 증명

```

#### 증명 연습

- `Trivial Proof` : All x에 대해서 P(x) -> Q(x)를 증명하려는데, Q(x)가 항상 참인 경우
  - 실수 x에 대해, 만약 x < -1 이면 x^2 + 1/4 > 0
  - n이 홀수이면 4 n^3 + 6 n^2 + 12는 짝수이다.
- Vacuous Proof : All x에 대해서 P(x) -> Q(x)를 증명하려는데, P(x)가 항상 거짓인 경우
  - p : F , p : ?



### 1.3. 연습

```python
# 문제1. 항진명제라는 것을 진리표를 이용해서 보이시오
1. ~(~p ^ q) V q
2. (~p V q) V (p ^ ~q)
```

```python
# 문제2. 모순명제라는 것을 진리표를 이용해서 보이시오
1. (~p V q) V (p ^ ~q)
2. (p ^ q) ^ (p ^ ~q)
```

```python
# 문제3. 두 명제가 동등한지를 진리표를 이용해서 보이시오
1. p ^ (p V q)와 p
2. ~p V ~q 와 ~(p V q)
```

```python
# 문제4. 명제식의 변형을 통하여 다음 명제를 간소화하시오.
1. (p ^ ~q) V (p ^ q) = p ^ (~q V q)
2. (p V ~q) ^ (~p V ~q) = (p ^ ~p) V ~q
```

```python
# 문제5. 다음 명제들이 참인지 확인하시오.
A : All
E : Existence
```

```python
# 문제6. (직접 증명) n이 짝수이면 3n + 5는 홀수임을 증명하라.
# 힌트 : n = 2k로 두고 3n + 5가 2(어떤 정수) + 1 형태로 표현될 수 있는지..
```

```python
# 문제7. m이 짝수이고 n이 홀수이면 2m + 3n은 홀수임을 증명하라.
```

```python
# 문제8. n^2 + 5가 홀수이면 n은 짝수임을 증명하라.
# 힌트 : 대우 -> n이 홀수이면 n^2 + 5는 짝수임을 증명한다
```

```python
# 문제9. n^2이 짝수이면 n은 짝수임을 증명하라.
# 힌트 : 대우 -> n이 홀수이면 n^2은 홀수이다.
```

```python
# 과제 : n^2이 3의 배수이면 n은 3의 배수임을 증명하라
# 대우 -> n이 3의 배수가 아니면, n^2이 3의 배수가 아니다.
1) 
n = 3k + 1
n^2 = 9k^2 +6k + 1 = 3(3k^2 + 2k) + 1
n^2은 3의 배수가 아니다
2)
n = 3k + 2
n^2 = 9k^2 +12k + 4 = 3(3k^2 + 4k + 1) + 1
n^2은 3의 배수가 아니다

따라서 n이 3의 배수가 아니면 n^2은 3의 배수가 아니다라는 대우가 참이기 때문에, 위의 명제는 참이다.
```





## 2. 수와 표현

- 컴퓨터는 0 또는 1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2^k-1까지 표현 가능
- 2^k >= n + 1을 찾으면 됨
- 즉 k >= log(n+1) 약 log n 비트가 필요하다고 할 수 있음

```python
# 문제1. 2진수 표현에서 logn 비트로 표현할 수 있는 숫자 범위는?
2^k => 2^(logn) = n
```

```python
# 문제3. n이 충분히 큰 값일 때, 다음을 비교하라
1. 2n < n^2
2. 2^(n/2) ? 3^(n/2)
3. n^n > n!
4. 2n ? n^3/2
```

```python
# 문제4. x = log{a}(yz)일 때 x를 2를 밑으로 하는 로그들로 표현하시오. 단, 로그 함수의 인자는 모두 문자 하나여야 한다.

```

```python
# 문제5. 역함수를 구하시오
1. 
2. 
3. 
```



## 3. 집합과 조합론

### 집합

- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A와 B가 서로의 부분집합을 만족함을 보여주면 되는 것이다.

```python
# 다음 두 집합이 같다는 것을 상세히 증명해 보자
A = {x|x=2k+1. k는 자연수}, B={x|x=4k+1 혹은 x=4k+3, k는 자연수}
A에 포함되는 임의의 원소 x를 가정
1-1) x = 2k
1-2) x = 2k + 1
B에 포함되는 임의의 원소 y를 가정
2-1) y = 2k
2-2) y = 2k + 1
```

### 조합론

- 조합론은 경우의 수를 따지는 문제들을 보통 말한다
- 조합의 개수는 C를 이용하여 표현하기도 하지만 (5 2) = 10 와 같은 괄호 표현을 더 많이 쓴다.

```python
# 문제1. nCk + nCk-1 = n+1Ck 임을 증명하라

```

##### 귀납법

```python
# 문제2. 수학적 귀납법으로 증명하라

```

##### 귀류법

p이면 q이다 라는 명제가 있다. p이면 ~q이다 라는 것을 증명함으로써, 명제의 참거짓을 판별할 수 있는 방법이다.

```python
# 문제4. 귀류법을 이용하여 (A - B) ^ (B - A) = 0 임을 증명하라

```

```python
# 문제8. 8 x 8 체스 판에 말 두개를 놓으려고 한다. 아무 곳에나 놓아도 되지만 한 칸에 두개가 들어가지는 못한다. 가능한 방법은 모두 몇 가지인가?

64C2
```

```python
# 문제12. 52개의 카드를 이용해서 만들 수 있는 5개 카드의 조합은 몇가지인가?

```

```python
# 문제16. 52개의 카드를 이용해서 만들 수 있는 5개 카드의 조합중에서 숫자가 같은 카드가 한 쌍도 없는 경우는 몇 가지인가?

```



## 4. 기초 수식

- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식 방법을 알아봅시다.

```python
# 문제1. T(n) = T(n-1) + 1
O(N)
```

```python
# 문제2. T(n) = T(n-1) + n
T(0) = 1

```

```python
# 문제3. T(n) = T(n-1) + logn
T(0) = 1
T(n) = T(n-1) + logn
	 = 1 + log(n!) <= 1 + nlogn (점근적 상한)
O(nlogn)
```

```python
# 문제4. T(n) = T(n/2) + 1
T(1) = 1

```

```python
# 문제5. T(n) = T(n/2) + n
T(1) = 1
T(n) = T(n/4) + n/2 + n
	 = T(n/8) + n/4 + n/2 + n
     = ...
2^k = n 
k = logn
	 = T(n / 2^k) + n/2^k-1 + ... n/2 + n
     = T(1) + n*(1)
     = 1 + n
O(n)
```

```python
# 문제

```

## 5. 재귀

- 재귀란 자기 자신을 호출하는 함수, 그럼 끝날 수가 있는가가 중요!

> ##### 수학적 귀납법 증명
>
> (가) n이 0일 때 문제를 풀 수 있음
>
> (나) n-1에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있다.

```python
# 연습문제
"""
피보나치 수열 : 수도코드 작성, 정확성 증명 및 시간 복잡도 계산을 수행하라
"""
# 수도코드
fibo(n){
    if(n <= 2) return 1
    return fibo(n-1) + fibo(n-2)
}
# 정확성 증명
n = 1, 2 일때
fibo(n) = 1
n = k 일때
fibo(1), ... , fibo(k-1)을 만족한다고 가정하고
f(k) = f(k-1) + f(k-2)를 만족한다.

# 시간 복잡도
F(n) = T(n-1) + T(n-2) + 1
	 < 2T(n-1) + 1 (∵ 점근적 상한)

T(n) = 2T(n-1) + 1
	 = 2(2T(n-2) + 1) + 1 = 2^2T(n-2) + 2 + 1
     = ...
     = 2^kT(n-k) + 2^(k-1) + ... + 2 + 1
n = k
	 = 2^lognT(0) + 2^n -1
     = n + 2^n - 1
O(2^n)
```



## 6. 동적 프로그래밍

- 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과 값을 저장해 두고 불러 쓰는 것이다. 
- 상향식 DP
- 메모이제이션 vs 동적 프로그래밍
  - 동적 프로그래밍이 가장 빠르다.

#### Merge sort

```python
numbers = [2, 6, 1, 3, 4, 5, 7, 8]

def merge_sort(numbers):
    N = len(numbers)
    # base case
    if N < 2:
        return numbers
    
    mid_idx = N // 2
    left = numbers[:mid_idx]
    right = numbers[mid_idx:]
    
    sorted_left = merge_sort(left)
    sorted_right = merge_sort(right)
    
    merged = []
    l = r = 0
    while l < len(sorted_left) and r < len(sorted_right):
        if sorted_leftt[l] < sorted_right[r]:
            merged.append(sorted_left[l])
            l += 1
        else:
            merged.append(sorted_right[r])
            r += 1
    while l < len(sorted_left):
        merged.append(sorted_left[l])
        l += 1
    while r < len(sorted_right):
        merged.append(sorted_right[r])
        r += 1
    
    merged += sorted_left[l:]
    merged += sorted_left[r:]
    return merged      
```

#### 시간복잡도 계산

```python
T(n) = T(n/2) + T(n/2) + n
T(n) = 2^kT(n/2^k) + kn
(2^k = n -> k = logn)
T(n) = n + nlogn
∴ O(nlogn)
```

## 7. 조합론 프로그래밍 과제



## 8. 기초 알고리즘 프로그래밍 과제



