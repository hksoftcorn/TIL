[TOC]

# APS - 분할정복/백트래킹/트리

> 2021.04.19.

문제를 분할해서 해결하는 분할 정복 기법을 이해하고 대표적인 알고리즘인 퀵 정렬돠 병합 정렬에 대해 학습합니다. 상태 공간 트리의 모든 노드를 검색하는 백트래킹에 대해 학습합니다.  이진 트리의 특성을 이해하고 이진 트리의 중요한 연산인 탐색, 삽입, 삭제 알고리즘을 학습합니다.

## 1. 분할정복

- 문제 제시 : 가짜 동전 찾기
  - N개의 동전들 중에 가짜 동전이 하나 포함되어 있다. 가짜 동전은 진짜 동전에 비해 아주 조금 가볍다. 진짜 동전들의 무게가 동일하다고 할 때 양팔 저울을 이용해서 가짜 동전을 찾아보자.
- 설계 전략
  - 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눈다.
  - 정복 : 나눈 작은 문제를 각각 해결한다.
  - 통합 : 해결된 해답을 모은다.
- Top-down 접근법 : 분할 → 정복 → 통합
- i.g. 거듭 제곱 : O(log n)

```python
# 거듭 제곱
def Recursive_power(x, n):
    if n == 1: return x
    if n % 2 == 0: # 짝수라면
        y = Recursive_power(x, n/2)
        return y * y
    else: # 홀수라면
        y = Recursive_power(x, (n-1)/2)
        return y * y * x
```



### 병합 정렬 Merge Sort

여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식입니다.

- 분할 단계 : 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 계속합니다.
- 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합합니다.

```python
numbers = [2, 6, 1, 3, 4, 5, 7, 8]

def merge_sort(numbers):
    N = len(numbers)
    # base case
    if N < 2:
        return numbers
    
    mid_idx = N // 2
    left = numbers[:mid_idx]
    right = numbers[mid_idx:]
    
    sorted_left = merge_sort(left)
    sorted_right = merge_sort(right)
    
    merged = []
    l = r = 0
    while l < len(sorted_left) and r < len(sorted_right):
        if sorted_leftt[l] < sorted_right[r]:
            merged.append(sorted_left[l])
            l += 1
        else:
            merged.append(sorted_right[r])
            r += 1
    while l < len(sorted_left):
        merged.append(sorted_left[l])
        l += 1
    while r < len(sorted_right):
        merged.append(sorted_right[r])
        r += 1
    
    merged += sorted_left[l:]
    merged += sorted_left[r:]
    return merged      
```

```python
# 시간 복잡도
T(n) = T(n/2) + T(n/2) + n
T(n) = 2^kT(n/2^k) + kn
(2^k = n -> k = logn)
T(n) = n + nlogn
∴ O(nlogn)
```



### 퀵 정렬 Quick Sort

주어진 배열을 두 개로 분할하고, 각각을 정렬합니다.

- 차이점
  - 병합 정렬은 그냥 두 부분(절반)으로 나누는 반면, 퀵 정렬은 분할할 때 기준 아이템(pivot) 중심으로, 이보다 작으면 왼편 큰 것은 오른편에 위치
  - 각 부분 정렬이 끝난 후 병합정렬은 "병합" 작업이 필요하나, 퀵 정렬은 필요로 하지 않음

```python
def quicksort(A[], l, r):
    p = A[l] # 왼쪽을 피봇 값으로 설정
    i, j = l, r
    while i <= j:
        while A[i] <= p :i++
        while A[ㅓ] >= p :j--
        if i < j:
            A[i], A[j] = A[j], A[i]
    A[l], A[j] = A[j], A[l]
    return j    
```

- 피봇 선택

  - 왼쪽 끝 / 오른쪽 끝 / 임의의 세개 값 중에 중간 값

  

  

### 이진 검색 Binary Search

자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법입니다. 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행합니다. 단 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 합니다.

- 검색 과정
  - 자료의 중앙에 있는 원소를 고릅니다.
  - 중앙 원소의 값과 찾고자 하는 목표 값을 비교합니다.
  - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행합니다.
  - 찾고자 하는 값을 찾을 때까지 반복합니다.

```python
# 반복 구조



```

```python
# 재귀 구조


```



#### 분할 정복의 활용

- 병합 정렬은 외부 정렬의 기본이 되는 정렬 알고리즘입니다. 또한 멀티코어 CPU 나 다수의 프로세서에서 정렬 알고리즘을 병렬화하기 위해 병합 정렬 알고리즘이 활용됩니다.
- 퀵 정렬은 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘입니다.



## 2. 백트래킹

- 문제 제시 : Queen을 배치 할 수 있는 위치는?
  - 퀸 8개를 8 x 8 크기의 체스판 안에 서로를 공격할 수 없도록 배치하는 모든 경우를 구하시오
- 백트래킹 개념 
  - 여러 가지 선택지들이 존재하는 상황에서 한 가지를 선택합니다.
  - 선택이 이루어지면 새로운 선택지들의 집합이 생성됩니다.
  - 이런 선택을 반복하면서 최종 상태에 도달합니다.
    - 올바른 선택을 계속하면 목표 상태에 도달합니다.
  - i.g. 당첨 리프 노드 찾기
    - 루트에서 갈 수 있는 노드를 선택합니다.
    - 꽝 노드까지 도달하면 최근의 선택으로 되돌아와서 다시 시작합니다.
    - 더 이상의 선택지가 없다면 이전의 선택지로 돌아가서 다른 선택을 합니다.
    - 루트까지 돌아갔을 경우 더 이상 선택지가 없다면 답이 없는 것입니다.

- 백트래킹과 깊이 우선 탐색과의 차이
  - 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면(유망하지 않다) 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄입니다.
  - 깊이 우선 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단합니다.
  - 깊이 우선 탐색을 가하기에는 경우의 수가 너무나 많음. 
  - 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간을 요하므로 처리 불가능합니다.
- 백트래킹 기법
  - 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되도랑가 다음 자식 노드로 갑니다.
  - 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 합니다.
  - 가지치기 : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않습니다.
- 백트래킹 절차
  - 상태 공간 트리의 깊이 우선 검색을 실시
  - 각 노드가 유망한지를 점검함
  - 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속함

```python
# 
def checknod(node v):
    if promising(v):
        if there is a  solution at v:
            write the solution
        else:
            for each child u of v:
	            checknode( u )
                
```

```python
# 상태공간트리를 구축하여 문제를 해결
bool backtrack(선택 집합, 선택한 수, 모든 선택수):
    

```

```python
# {1, 2, 3} 의 pwerset을 구하는 백트래킹 알고리즘
# make_candidate()

```

```python
# 백트래킹을 이용하여 {순열} 구하기
# 후보 만들기
```



```python

```



















